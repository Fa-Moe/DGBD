#' Estimate the DGB Distribution Parameters
#'
#' Estimates the parameters of the DGB distribution (also known as the Beta-Cocho distribution) proposed in Martinez-Mekler et al. (2009) \doi{10.1371/journal.pone.0004791} for a given set of data.
#' \code{BC_param} calculates the log of the data and estimates the abundance from the ranking using a linear model.
#' The coefficients of the linear model are then scaled for future use.
#'
#' @param df_abundance A data frame that contains abundance data.
#' @param column_param Either a string with the name of the column or the number of the column that stores the abundances in the data frame.
#' @param confidence_interval Numeric. The confidence interval to calculate for the DGB distribution.
#' @param nls Logical. Set to TRUE to use a non-linear least squares fitting method from the 'gslnls' package.
#' @param nls_loop Numeric. Set to values higher than 1 to repeat the nls method as many times as needed, reseeding with the last value. This improves the fit with diminishing returns.
#' @param nls_algo String. The algorithm to use for the \code{gsl_nls} function.
#' @param nls_control List. Provided for the control argument for the \code{gsl_nls} function.
#' @param BC_rank_object Optional. A previous object generated by \code{BC_rank}.
#' @param ... passes arguments to \code{BC_rank}.
#'
#' @return A list with the following elements: The input data frame with added processed ranking data and predicted confidence interval values, the adjusted parameters, the confidence interval of the parameters, the linear model and a summary of the model.
#' @export
#'
#' @examples
#' BC_param(hmp_wgs,2,confidence_interval=0.99)
#'
#' BC_param(Tara_Data,column_param=2,is_phyloseq=TRUE,confidence_interval=0.9)
#'

BC_param <- function(df_abundance=NULL,column_param=NULL,confidence_interval=0.95,nls=FALSE,nls_loop=1,nls_algo="lm",nls_control=list(scale = "levenberg"),BC_rank_object=NULL,...){
  if(!is.null(BC_rank_object)){ranked_frame <- BC_rank_object}
  else if (!is.null(df_abundance)){ranked_frame <- BC_rank(df_abundance,column_rank=column_param,...)}
  else {stop("Neither an abundance data frame or a BC_param_object were provided")}
  r <- ranked_frame[,"BC_rank"]
  N <- max(r)
  pre_numerator <- N+1-r
  pre_denominator <- r
  log_num <- log(pre_numerator)
  log_den <- log(pre_denominator)
  log_abundance  <- log(ranked_frame[,"abundance"])
  lfit <- stats::lm(log_abundance~log_den+log_num)
  params <- c(exp(stats::coef(lfit)[1]),-1*stats::coef(lfit)[2],stats::coef(lfit)[3])
  names(params) <- c("A","a","b")
  conf_inter <- stats::predict(lfit, interval = "confidence", level = confidence_interval)
  conf_inter <- exp(conf_inter)
  param_conf <- stats::confint(lfit,level=confidence_interval)
  param_conf[1,] <- exp(param_conf[1,])
  param_conf[2,] <- -1*param_conf[2,]
  if (nls){
    for (hidden in 1:nls_loop){
    nlsfit <- gslnls::gsl_nls(
    fn = abundance ~ A * ((max(BC_rank)+1-BC_rank)^b)/(BC_rank^a),
    data = ranked_frame,
    start = list(A = params[1], a = params[2], b = params[3]),
    algorithm = nls_algo,
    control = nls_control)
    lfit <- nlsfit
    params <-  summary(nlsfit)$coefficients[,1]
    conf_inter <- stats::predict(lfit, interval = "confidence", level = confidence_interval)
    conf_inter <- ifelse(conf_inter <= 0, .Machine$double.eps, conf_inter)
    param_conf <- stats::confint(lfit,level=confidence_interval)
    }
  }
  output_frame <- cbind(pre_numerator,pre_denominator,conf_inter[,2:3],ranked_frame)
  output <- list(output_frame,params,param_conf,lfit,summary(lfit))
  return(output)
}
